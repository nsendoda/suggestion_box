<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>オーナーダッシュボード</title>

    <!-- テーマ（前回の #ネガハ CSS） -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Potta+One&family=Zen+Maru+Gothic:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/negahapi.css" />
    <style>
      /* ちょい足し */
      .toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .spacer {
        flex: 1;
      }
      .close {
        x: -;
      }
      .close {
        background: transparent;
        border: none;
        color: #aaa;
        font-size: 14px;
        cursor: pointer;
      }
      .close:hover {
        color: #fff;
        text-decoration: underline;
      }

      /* でかボタン + 祝祭感 */
      .btn-giant {
        font-size: clamp(18px, 2.2vw + 8px, 28px);
        padding: 18px 30px;
        border-radius: 9999px;
        background: linear-gradient(135deg, #ff6aa9, #ff8d8d, #ffb86c);
        color: #fff;
        box-shadow: 0 14px 34px rgba(255, 110, 150, 0.35);
        letter-spacing: 0.04em;
        position: relative;
        overflow: hidden;
        transform: translateZ(0); /* GPU */
        animation: ringPulse 2.4s ease-in-out infinite;
      }
      .btn-giant:hover {
        transform: translateY(-1px) scale(1.02);
      }
      .btn-giant:active {
        transform: translateY(1px) scale(0.99);
      }
      .btn-giant:disabled {
        opacity: 0.65;
        cursor: progress;
        filter: saturate(0.6);
      }

      .btn-giant .ico {
        margin-right: 0.5em;
        filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.15));
      }

      @keyframes ringPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 141, 141, 0.55);
        }
        70% {
          box-shadow: 0 0 0 22px rgba(255, 141, 141, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 141, 141, 0);
        }
      }

      /* 既存の下に追記 */
      h1 {
        text-align: center;
      }

      /* 置き換え */
      .toolbar-center {
        display: grid;
        grid-template-columns: 1fr auto 1fr; /* 左スペーサ / まん中 / 右リンク */
        gap: 14px;
        align-items: center;
      }
      .toolbar-center > .center-wrap {
        grid-column: 2; /* まん中の列を常に使う */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        text-align: center;
      }
      .toolbar-center > a {
        grid-column: 3; /* 右端の列 */
        justify-self: end;
      }

      /* モバイル時は1カラム＋右下にリンク */
      @media (max-width: 560px) {
        .toolbar-center {
          grid-template-columns: 1fr;
        }
        .toolbar-center > a {
          grid-column: auto;
          justify-self: end;
        }
      }

      /* ロック中のビジュアル（任意） */
      .btn-giant.is-locked {
        opacity: 0.65;
        cursor: not-allowed;
        filter: saturate(0.6);
        animation-play-state: paused;
      }
    </style>
  </head>
  <body>
    <header class="nav">
      <div class="brand">
        投書箱<span class="sub"> 世界の声を聴くrutubo</span>
      </div>
      <div class="toolbar">
        <button
          id="copyLink"
          class="btn btn-ghost"
          title="自分の投書ページURLをコピー"
        >
          投書ページURLをコピー
        </button>
      </div>
    </header>

    <main class="wrap">
      <h1>オーナーダッシュボード</h1>
      <div class="toolbar toolbar-center" style="margin: 12px 0 20px">
        <div class="center-wrap">
          <button id="draw" class="btn btn-contrast btn-giant">
            <span class="ico">🎉</span> 投書箱から一枚引く
          </button>
          <div class="hint">上限に達していると引けません</div>
        </div>

        <!-- 右端 -->
        <a class="btn btn-ghost" href="/owner/list">一覧を見る</a>
      </div>

      <!-- 引いたカード -->
      <section
        id="drawn"
        class="card floaty"
        style="display: none; margin: 10px 0 16px"
      >
        <div class="meta">
          <span id="statusBadge" class="badge keep">保留中</span>
          <span class="hint" id="drawnTime"></span>
        </div>
        <div
          id="drawnContent"
          style="white-space: pre-wrap; font-size: 16px; margin-top: 8px"
        ></div>
        <div class="actions" style="margin-top: 12px">
          <button class="btn btn-contrast" id="btnDone">完了</button>
          <button class="btn btn-primary" id="btnHold">保留</button>
          <button class="btn btn-ghost" id="btnDrop">棄却</button>
          <button class="close" id="btnClose" title="閉じる（保留のまま）">
            × とじる
          </button>
          <a
            id="btnTweet"
            class="btn btn-ghost"
            target="_blank"
            rel="noopener"
            style="display: none"
            >X で共有</a
          >
        </div>
      </section>

      <div id="toast" class="hint"></div>
    </main>

    <script>
      (() => {
        // ===== ユーティリティ =====
        const $ = (id) => document.getElementById(id);
        let ownerId = null;
        let ownerDisplayName = null;

        let currentId = null; // ← 表示中カードのID（ロック判定に使用）
        let drawing = false; // ← 通信の連打防止

        /* 追加：ロックの切替（見た目も変更） */
        function setDrawLock(locked) {
          const btn = $("draw");
          if (!btn) return;
          btn.disabled = locked;
          btn.classList.toggle("is-locked", locked);
        }

        function showToast(msg, ms = 1400) {
          const t = $("toast");
          if (!t) return;
          t.textContent = msg;
          setTimeout(() => (t.textContent = ""), ms);
        }

        // 自分情報
        async function getMe() {
          const r = await fetch("/api/me");
          if (!r.ok) {
            location.href = "/login.html";
            return;
          }
          const me = await r.json(); // { ownerId, displayName? } or { id }
          ownerId = me.ownerId || me.id;
          ownerDisplayName = me.displayName || "@" + ownerId;

          // displayName 未返却の環境向けフォールバック（あれば）
          if (!me.displayName) {
            try {
              const pr = await fetch(`/api/owners/${ownerId}/profile`);
              if (pr.ok) {
                const p = await pr.json();
                if (p.displayName) ownerDisplayName = p.displayName;
              }
            } catch {}
          }
          return ownerId;
        }

        // URL コピー
        async function copyMyBoxUrl() {
          const url = `${location.origin}/box.html?o=${encodeURIComponent(
            ownerId
          )}`;
          try {
            await navigator.clipboard.writeText(url);
            showToast("URLをコピーしました");
          } catch {
            const ta = document.createElement("textarea");
            ta.value = url;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
            showToast("URLをコピーしました");
          }
        }

        // 20 文字プレビュー（全角混在ざっくり）
        function preview20(s) {
          const arr = [...s];
          return arr.length > 20 ? arr.slice(0, 20).join("") + "…" : s;
        }

        // ===== ド派手コンフェッティ（毎回発火OK） =====
        function megaConfetti({
          duration = 2200,
          bursts = 3,
          particles = 220,
        } = {}) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const dpr = devicePixelRatio || 1;
          let w = innerWidth,
            h = innerHeight;
          canvas.style.cssText =
            "position:fixed;inset:0;z-index:9999;pointer-events:none";
          canvas.width = w * dpr;
          canvas.height = h * dpr;
          ctx.scale(dpr, dpr);
          document.body.appendChild(canvas);

          // テキスト
          const textEl = document.createElement("div");
          textEl.textContent = "おめでとう！";
          textEl.style.cssText =
            "position:fixed;left:50%;top:22%;transform:translate(-50%,-50%) scale(.9);" +
            'font:800 clamp(28px,4vw,54px)/1 "Zen Maru Gothic",system-ui;color:#fff;' +
            "text-shadow:0 6px 18px rgba(255,110,150,.55),0 0 22px rgba(255,255,255,.7);" +
            "filter:drop-shadow(0 3px 10px rgba(0,0,0,.25));opacity:0;z-index:10000;";
          document.body.appendChild(textEl);
          requestAnimationFrame(() => {
            textEl.style.transition =
              "transform .8s cubic-bezier(.2,.9,.2,1),opacity .8s";
            textEl.style.opacity = "1";
            textEl.style.transform = "translate(-50%,-50%) scale(1)";
          });

          const colors = [
            "#ff2e92",
            "#ffb86c",
            "#7af0ff",
            "#b8ff3e",
            "#ffffff",
          ];
          const shapes = ["rect", "circle", "tri", "emoji"];
          const P = [];
          function spawnBurst(cx, cy, n) {
            for (let i = 0; i < n; i++) {
              const ang = Math.random() * Math.PI * 2;
              const spd = 3 + Math.random() * 6;
              const size = 4 + Math.random() * 8;
              const shape =
                shapes[
                  Math.random() < 0.12 ? 3 : Math.floor(Math.random() * 3)
                ];
              P.push({
                x: cx,
                y: cy,
                vx: Math.cos(ang) * spd,
                vy: Math.sin(ang) * spd - 2,
                g: 0.12 + Math.random() * 0.1,
                fr: 0.007 + Math.random() * 0.01,
                rot: Math.random() * Math.PI,
                vr: (Math.random() - 0.5) * 0.25,
                size,
                color: colors[Math.floor(Math.random() * colors.length)],
                life: 1,
                shape,
                emoji: ["✨", "🎉", "⭐"][Math.floor(Math.random() * 3)],
              });
            }
          }
          const shots = [
            [w * 0.5, h * 0.35],
            [w * 0.15, h * 0.28],
            [w * 0.85, h * 0.28],
          ];
          for (let b = 0; b < bursts; b++) {
            setTimeout(
              () =>
                shots.forEach(([cx, cy]) =>
                  spawnBurst(cx, cy, Math.round(particles / shots.length))
                ),
              b * (duration / bursts)
            );
          }
          const start = performance.now();
          function tick(t) {
            ctx.clearRect(0, 0, w, h);
            for (const p of P) {
              p.vy += p.g;
              p.vx *= 1 - p.fr;
              p.vy *= 1 - p.fr;
              p.x += p.vx;
              p.y += p.vy;
              p.rot += p.vr;
              p.life -= 0.008;
              ctx.save();
              ctx.globalAlpha = Math.max(p.life, 0.05);
              ctx.translate(p.x, p.y);
              ctx.rotate(p.rot);
              if (p.shape === "rect") {
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
              } else if (p.shape === "circle") {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                ctx.fill();
              } else if (p.shape === "tri") {
                ctx.fillStyle = p.color;
                const s = p.size;
                ctx.beginPath();
                ctx.moveTo(0, -s / 2);
                ctx.lineTo(-s / 2, s / 2);
                ctx.lineTo(s / 2, s / 2);
                ctx.closePath();
                ctx.fill();
              } else {
                ctx.font = `${
                  p.size * 1.6
                }px system-ui,"Apple Color Emoji","Segoe UI Emoji"`;
                ctx.fillText(p.emoji, -p.size / 2, p.size / 2);
              }
              ctx.restore();
            }
            if (
              t - start < duration ||
              P.some((p) => p.life > 0 && p.y < h + 40)
            ) {
              requestAnimationFrame(tick);
            } else {
              canvas.remove();
              textEl.style.opacity = "0";
              textEl.style.transform = "translate(-50%,-50%) scale(.96)";
              setTimeout(() => textEl.remove(), 350);
            }
          }
          requestAnimationFrame(tick);
        }

        // ===== 1枚引く =====
        $("draw").onclick = async () => {
          // ★表示中のカードがある間は引かせない
          if (currentId) {
            alert(
              "先に表示中のカードを「完了 / 保留 / 棄却」で処理してください。"
            );
            return;
          }
          if (drawing) return;
          drawing = true;
          const btn = $("draw");
          btn.disabled = true;

          try {
            const res = await fetch(`/api/owners/${ownerId}/draw`, {
              method: "POST",
            });
            if (!res.ok) {
              const txt = await res.text();
              alert(`引けませんでした：${res.status}\n${txt.slice(0, 200)}`);
              return;
            }
            const data = await res.json(); // { id, content }
            currentId = data.id;

            $("drawnContent").textContent = data.content;
            $("statusBadge").textContent = "保留中";
            $("drawnTime").textContent = new Date().toLocaleString();
            $("drawn").style.display = "block";

            // 祝砲
            megaConfetti();

            // X共有リンク（省略せず従来通り）
            const shareUrl = `${location.origin}/letter.html?id=${currentId}`;
            const text = `${ownerDisplayName}さんへの投書が届いたよ！\n「${[
              ...data.content,
            ]
              .slice(0, 20)
              .join("")}${[...data.content].length > 20 ? "…" : ""}」\n`;
            const a = $("btnTweet");
            if (a) {
              a.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(
                text
              )}&url=${encodeURIComponent(shareUrl)}`;
              a.style.display = "inline-flex";
            }

            // ★カード表示中はロック
            setDrawLock(true);
          } finally {
            drawing = false;
            // 通信は終わったが、カードが出ている間はロック維持
            if (!currentId) btn.disabled = false;
          }
        };

        /* 置き換え：状態更新（完了/棄却/保留） */
        $("btnDone").onclick = () => updateCurrent("完了");
        $("btnDrop").onclick = () => updateCurrent("棄却");
        $("btnHold").onclick = () => updateCurrent("保留"); // APIは「保持」に変換

        async function updateCurrent(label) {
          if (!currentId) return;
          const apiStatus = label === "保留" ? "保持" : label;
          const res = await fetch(
            `/api/owners/${ownerId}/letters/${currentId}/status`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ status: apiStatus }),
            }
          );
          if (!res.ok) {
            const txt = await res.text();
            alert(`更新失敗：${res.status}\n${txt.slice(0, 200)}`);
            return;
          }
          $("drawn").style.display = "none";
          currentId = null;
          setDrawLock(false); // ★ロック解除
        }

        /* 置き換え：×とじる（APIは呼ばない＝保持のまま） */
        $("btnClose").onclick = () => {
          $("drawn").style.display = "none";
          currentId = null; // ★表示は消えた＝次を引ける
          setDrawLock(false); // ★ロック解除
        };

        // 初期化
        (async () => {
          const r = await fetch("/api/me");
          if (!r.ok) {
            location.href = "/login.html";
            return;
          }
          const me = await r.json();
          ownerId = me.ownerId || me.id;
          ownerDisplayName = me.displayName || "@" + ownerId;

          $("copyLink").onclick = async () => {
            const url = `${location.origin}/box.html?o=${encodeURIComponent(
              ownerId
            )}`;
            try {
              await navigator.clipboard.writeText(url);
            } catch {}
          };
        })();
      })();
    </script>
  </body>
</html>
